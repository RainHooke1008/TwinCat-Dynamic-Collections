<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.4">
  <POU Name="FB_List" Id="{cd7ab84c-8cf5-48a0-b672-a87b851e57bd}" SpecialFunc="None">
    <Declaration><![CDATA[// Dyanamic List that can store a collection of any types. Similiar to python lists.
FUNCTION_BLOCK FB_List EXTENDS FB_Collections IMPLEMENTS I_List
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	
	nSize 		: DINT; // Size of list
	pHead: POINTER TO ST_NODE;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Exceptions" Id="{e82626be-e97a-42fa-8de6-06baa9d2a4f3}" />
    <Folder Name="Protected" Id="{a8398322-c939-46f8-89c4-344fbe448dfa}" />
    <Property Name="_Count" Id="{45811505-20d9-43d3-b8e1-1877573a1872}">
      <Declaration><![CDATA[// Number of elements in list
PROPERTY PUBLIC _Count : DINT]]></Declaration>
      <Get Name="Get" Id="{d61ae709-db2b-4f39-9ff8-4edc48d3d51f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_Count := nSize;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="_Is_Empty" Id="{754c9bbb-2b9f-40dc-87b7-da6c134062d3}">
      <Declaration><![CDATA[(* Checks of list is empty.*)
PROPERTY _Is_Empty : BOOL
]]></Declaration>
      <Get Name="Get" Id="{d6e470fa-f933-4e4f-a1e0-34b2f07444c5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_Is_Empty := (THIS^._Count = 0) AND (THIS^.pHead = 0);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Add_Front" Id="{d1e167e9-404b-42b0-a3b8-fb3d5edcb888}">
      <Declaration><![CDATA[// Creates/Adds an node to the front of the list
METHOD Add_Front : I_List
VAR_INPUT
	Value 	: ANY; // Value to store in node
END_VAR
VAR
	pTemp 	: POINTER TO ST_NODE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Add_Front := THIS^;
pTemp := THIS^.Malloc_Node(Value);
THIS^.CopyValueTo(pTemp^.Data, Value);

pTemp^.pNext := THIS^.pHead; THIS^.pHead := pTemp;
THIS^.IncrementSize();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Clear" Id="{b6fe176d-87fe-4578-bef8-d75706130afd}">
      <Declaration><![CDATA[(* Empties/Clears/Deletes every node on the list*)
METHOD Clear
VAR
	pTemp : POINTER TO ST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pTemp := THIS^.pHead;
WHILE pTemp <> 0 DO
	pTemp := pTemp^.pNext; THIS^.Remove();
END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="ClearException" Id="{eba76d05-edf5-42d2-b698-b1f111568f1d}" FolderPath="Exceptions\">
      <Declaration><![CDATA[METHOD PROTECTED ClearException : BOOL;
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ClearException 	:= stError.bSTATUS := FALSE;
stError.nCODE 	:= 0;
stError.sSOURCE := 'No error.';]]></ST>
      </Implementation>
    </Method>
    <Method Name="CopyValueTo" Id="{367be9d8-8fab-4f32-a92e-eae00c30bb0d}" FolderPath="Protected\">
      <Declaration><![CDATA[// Copy data from source memory space to desination memory space
METHOD PROTECTED CopyValueTo
VAR_INPUT
	Dest, Src : __SYSTEM.AnyType;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MEMMOVE(Dest.pValue, Src.pValue, TO_UDINT(Dest.diSize));]]></ST>
      </Implementation>
    </Method>
    <Method Name="Create" Id="{a0af254c-946d-47c4-ade0-ee9e9686d99a}">
      <Declaration><![CDATA[// Creates/Adds an node to the end of the list
METHOD Create : I_List
VAR_INPUT
	Value 	: ANY; // Value to store in node
END_VAR
VAR
	pTemp 	: POINTER TO ST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Create := THIS^;
pTemp := THIS^.Malloc_Node(Value);
THIS^.CopyValueTo(pTemp^.Data, Value);

IF THIS^._Is_Empty THEN THIS^.pHead := pTemp;
ELSE Iterate(THIS^._Count - 1)^.pNext := pTemp; END_IF

THIS^.IncrementSize();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="DecrementSize" Id="{f5c6a93f-7fd5-483d-bee3-0741bd56da1e}" FolderPath="Protected\">
      <Declaration><![CDATA[// Decrement list size by 1.
METHOD PROTECTED DecrementSize
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.nSize := THIS^.nSize - 1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="EmptyListException" Id="{55815463-fe44-42bc-bfcd-f7e04253be21}" FolderPath="Exceptions\">
      <Declaration><![CDATA[// Raises an expection if list is empty
METHOD PROTECTED EmptyListException : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^._Is_Empty THEN
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 2936;
	stError.sSOURCE := 'List is empty';
ELSE
	This^.ClearException();
	END_IF
EmptyListException := stError.bSTATUS;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_exit" Id="{f8f1941e-3bec-4920-923c-f8ff0e64d371}">
      <Declaration><![CDATA[METHOD FB_exit : BOOL
VAR_INPUT
	(* if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change).*)
	bInCopyCode	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[This^.Clear();]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{abd63a4c-4d44-4c61-b727-d8ff5361b548}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.Clear();
THIS^.pHead := Tc3_Module.GVL.NULL;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Free_Node" Id="{02d09404-9549-42a6-8485-a497a2cb2e7c}" FolderPath="Protected\">
      <Declaration><![CDATA[// Deletes/frees node and it's value from memory
METHOD PROTECTED Free_Node
VAR_INPUT
	pNode : POINTER TO ST_NODE; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[__DELETE(pNode^.Data.pValue);
__DELETE(pNode);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get" Id="{b6a703e7-0a5d-4851-98c3-47db19fc8800}">
      <Declaration><![CDATA[(* Gets value from node at specified location;*)
METHOD Get : I_List
VAR_INPUT
	Return_Value 	: ANY;(* Variable to store requested node value*)
	nIndex			: DINT; (* Location of node*)
END_VAR
VAR
	pTemp : POINTER TO ST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Get := THIS^;
IF THIS^.EmptyListException() OR THIS^.OutOfBoundsException(nIndex) THEN THIS^.SetValue(Return_Value, 16#0); RETURN; END_IF
pTemp := Iterate(nIndex);
IF THIS^.TypeMismatchException(Return_Value, pTemp^.Data) THEN THIS^.SetValue(Return_Value, 16#0); RETURN; END_IF
THIS^.CopyValueTo(Return_Value, pTemp^.Data);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get_First" Id="{1740d573-9e96-4fa7-8b8e-097f14cca257}">
      <Declaration><![CDATA[(* Gets value from first node. *)
METHOD Get_First : I_List
VAR_INPUT
	Return_Value : ANY; // Variable to store returned value
END_VAR
VAR
	pTemp 	: POINTER TO ST_NODE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Get_First := THIS^;
IF THIS^.TypeMismatchException(Return_Value, pHead^.Data) OR THIS^.EmptyListException() THEN THIS^.SetValue(Return_Value, 16#0); RETURN; END_IF
THIS^.CopyValueTo(Return_Value, pHead^.Data);
Get_First := THIS^;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="IncrementSize" Id="{cd1c7f1a-3e2d-495d-af20-c7cb051ba47a}" FolderPath="Protected\">
      <Declaration><![CDATA[// Increments list size by 1
METHOD PROTECTED IncrementSize
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.nSize := THIS^.nSize + 1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Insert" Id="{d1c1df37-9a45-4784-9e40-5a5c13d4e5c0}">
      <Declaration><![CDATA[(* Adds new node to list at specified location*)
METHOD Insert : I_List
VAR_INPUT
	Value	: ANY;(* Value to store in node*)
	nIndex	: DINT;(* Location of node*)
END_VAR
VAR
	pPrevious 	: POINTER TO ST_NODE;
	pCurrent 	: POINTER TO ST_NODE;
	pTemp 		: POINTER TO ST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Insert := THIS^;
IF nIndex = THIS^._Count THEN THIS^.Create(Value); END_IF
IF THIS^.OutOfBoundsException(nIndex) THEN RETURN; END_IF
IF nIndex = 0 THEN THIS^.Add_Front(Value); RETURN; END_IF

pTemp := THIS^.Malloc_Node(Value);
THIS^.CopyValueTo(pTemp^.Data, Value);

pPrevious := THIS^.Iterate(nIndex-1);
pCurrent := pPrevious^.pNext;
pPrevious^.pNext := pTemp;
pTemp^.pNext := pCurrent;

THIS^.IncrementSize();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Iterate" Id="{3f260d2d-41c5-4522-9600-f0e44652c9c1}" FolderPath="Protected\">
      <Declaration><![CDATA[// Returns pointer to node at specificied location;
METHOD PROTECTED Iterate : POINTER TO ST_NODE
VAR_INPUT
	nIndex : DINT;
END_VAR
VAR 
	i 		: DINT;
	pTemp 	: POINTER TO ST_NODE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.OutOfBoundsException(nIndex) THEN RETURN; END_IF
IF nIndex = 0 THEN Iterate := THIS^.pHead; RETURN; END_IF
//IF nIndex = THIS^._Count-1 THEN Iterate := pTail; RETURN; END_IF
pTemp := pHead;
FOR i := 1 TO nIndex DO pTemp := pTemp^.pNext; END_FOR
Iterate := pTemp;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Malloc_Node" Id="{60d4af61-bd84-45a7-abf0-e95fcd7a5566}" FolderPath="Protected\">
      <Declaration><![CDATA[// Allocate memory space for node and the value for it's data on the heap, returns pointer to node;
// WARNING!!! Always have a place to store the node pointer otherwise a memory leak will occur.
METHOD PROTECTED Malloc_Node : POINTER TO ST_NODE
VAR_INPUT
	Variable : __SYSTEM.AnyType;
END_VAR
VAR
	pTemp 	: POINTER TO ST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pTemp := __NEW(ST_NODE); // Allocate space in memory for a node.
pTemp^.Data := Variable;
pTemp^.Data.pValue := __NEW(BYTE, TO_UDINT(Variable.diSize)); // Allocate space in memory to store data value.
Malloc_Node := pTemp;]]></ST>
      </Implementation>
    </Method>
    <Method Name="MemCmpErrExpection" Id="{a349bc9f-b56b-4ce2-979e-c1ef93efac97}" FolderPath="Exceptions\">
      <Declaration><![CDATA[// Compares memory sizes of 2 addresses. Returns TRUE  and raises error flag if theyre not same size.
METHOD PROTECTED MemCmpErrExpection : BOOL
VAR_INPUT
	pDestAddr,
	pSrcAddr 	: PVOID;
	nSize 		: UDINT;
END_VAR
VAR_INST
	nMemErr : DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nMemErr := MEMCMP(pDestAddr, pSrcAddr, nSize);
IF nMemErr = -1 THEN 
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 4129;
	stError.sSOURCE := 'Incorrect parameter values. Destination address smaller than source address';
	
ELSIF nMemErr = 0 THEN THIS^.ClearException();
	
ELSIF nMemErr = 1 THEN
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 4823;
	stError.sSOURCE := 'Incorrect parameter values. Destination address greater that source address';

ELSE
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 4564;
	stError.sSOURCE := 'Incorrect parameter values. Pointer to destination/source address is NULL or allocated address memory is NULL.';
	END_IF

MemCmpErrExpection := stError.bSTATUS;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="OutOfBoundsException" Id="{1f426817-b7ae-4dd1-aa32-841e2c4e2fc5}" FolderPath="Exceptions\">
      <Declaration><![CDATA[METHOD PROTECTED OutOfBoundsException : BOOL
VAR_INPUT
	nIndex : DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (nIndex < 0) OR (nIndex >= THIS^._Count) THEN
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 5374;
	stError.sSOURCE := 'Out of bounds. You tried to access data outside the range of this list.';
ELSE
	This^.ClearException();
	END_IF
OutOfBoundsException := stError.bSTATUS;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Remove" Id="{2b611fa2-a17e-40ea-ba6d-5110e1358095}">
      <Declaration><![CDATA[(* Removes node at the front of the list and returns nothing. *)
METHOD Remove : I_List
VAR
	pTemp 	: POINTER TO ST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Remove := THIS^;
IF THIS^._Is_Empty THEN RETURN; END_IF

pTemp := THIS^.pHead^.pNext;
THIS^.Free_Node(pHead);
THIS^.pHead := pTemp;

THIS^.DecrementSize();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="RemoveAt" Id="{53ed1eb1-f86e-4345-bb56-10c2b75ebbe4}">
      <Declaration><![CDATA[(* Remove node at specific loacation and return nothing *)
METHOD RemoveAt : I_List
VAR_INPUT
	nIndex	: DINT;(* Location of node*)
END_VAR
VAR
	pTemp : ARRAY[1..2] OF POINTER TO ST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[RemoveAt := THIS^;
IF THIS^.EmptyListException() OR THIS^.OutOfBoundsException(nIndex)  THEN RETURN; END_IF
IF nIndex = 0 THEN THIS^.Remove(); RETURN; END_IF

pTemp[1] := THIS^.Iterate(nIndex-1);
pTemp[2] := pTemp[1]^.pNext^.pNext;
THIS^.Free_Node(pTemp[1]^.pNext);
pTemp[1]^.pNext := pTemp[2];

THIS^.DecrementSize();

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reverse" Id="{6273f1ac-e12f-4ef5-9f8c-c1b9acfa9d9a}">
      <Declaration><![CDATA[(* Reverses list*)
METHOD Reverse : I_List
VAR
	pPrevious 	: POINTER TO ST_NODE;
	pCurrent 	: POINTER TO ST_NODE;
	pNext	 	: POINTER TO ST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Reverse := THIS^;
pCurrent := pHead;
WHILE pCurrent <> 0 DO
	pNext := pCurrent^.pNext;
	pCurrent^.pNext := pPrevious;
	pPrevious := pCurrent;
	pCurrent := pNext;
END_WHILE
THIS^.pHead := pPrevious;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Set" Id="{7fbd9caf-c554-4b43-a075-5d2face1d5e9}">
      <Declaration><![CDATA[(* Sets value of node at specified location;*)
METHOD Set : I_List
VAR_INPUT
	Value	: ANY; (* Value to store in node*)
	nIndex	: DINT; (* Location of node*)
END_VAR
VAR
	pTemp : POINTER TO ST_NODE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Set := THIS^;
IF THIS^.OutOfBoundsException(nIndex) THEN RETURN; END_IF
pTemp := Iterate(nIndex);
IF THIS^.TypeMismatchException(pTemp^.Data, Value) THEN RETURN; END_IF
THIS^.CopyValueTo(pTemp^.Data, Value);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetValue" Id="{8cf22491-1e96-43a3-8de0-89dd4d61d171}" FolderPath="Protected\">
      <Declaration><![CDATA[(* Set value of __SYSTEM.Anytype variable *)
METHOD PROTECTED SetValue
VAR_INPUT
	Variable	: __SYSTEM.Anytype;
	Value 		: USINT; // Character/byte to set.
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MEMSET(Variable.pValue, Value, TO_UDINT(Variable.diSize));]]></ST>
      </Implementation>
    </Method>
    <Method Name="TypeMismatchException" Id="{c1057f0b-a015-4c9c-b6df-7b0af3fc3916}" FolderPath="Exceptions\">
      <Declaration><![CDATA[METHOD TypeMismatchException : BOOL
VAR_INPUT
	Dest,
	Src 	: __SYSTEM.AnyType;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Dest.diSize <> Src.diSize THEN
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 3172;
	stError.sSOURCE := 'Type mismatch. Byte sizes are not the same';
ELSIF Dest.TypeClass <> Src.TypeClass THEN
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 3172;
	stError.sSOURCE := 'Type mismatch. Type classes are not the same';
ELSE
	THIS^.ClearException();
END_IF
TypeMismatchException := stError.bSTATUS;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_List">
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_List._Count.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_List._Is_Empty.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Add_Front">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Clear">
      <LineId Id="9" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.ClearException">
      <LineId Id="6" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.CopyValueTo">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Create">
      <LineId Id="204" Count="0" />
      <LineId Id="189" Count="0" />
      <LineId Id="181" Count="0" />
      <LineId Id="202" Count="0" />
      <LineId Id="201" Count="0" />
      <LineId Id="203" Count="0" />
      <LineId Id="169" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="170" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.DecrementSize">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.EmptyListException">
      <LineId Id="13" Count="5" />
      <LineId Id="8" Count="0" />
      <LineId Id="19" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.FB_exit">
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.FB_init">
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Free_Node">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Get">
      <LineId Id="51" Count="0" />
      <LineId Id="38" Count="2" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Get_First">
      <LineId Id="139" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="138" Count="0" />
      <LineId Id="117" Count="1" />
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.IncrementSize">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Insert">
      <LineId Id="31" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="61" Count="1" />
      <LineId Id="60" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="55" Count="2" />
      <LineId Id="59" Count="0" />
      <LineId Id="58" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Iterate">
      <LineId Id="5" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="24" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Malloc_Node">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="1" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.MemCmpErrExpection">
      <LineId Id="131" Count="19" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.OutOfBoundsException">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="4" />
      <LineId Id="6" Count="0" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Remove">
      <LineId Id="30" Count="0" />
      <LineId Id="9" Count="1" />
      <LineId Id="12" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="15" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.RemoveAt">
      <LineId Id="37" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="25" Count="0" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Reverse">
      <LineId Id="21" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="8" Count="6" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Set">
      <LineId Id="54" Count="0" />
      <LineId Id="40" Count="2" />
      <LineId Id="24" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="43" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.SetValue">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.TypeMismatchException">
      <LineId Id="5" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="11" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="24" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>